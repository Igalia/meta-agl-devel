From 92478e4e9839b8485a751cbe6009ebbffd39df86 Mon Sep 17 00:00:00 2001
From: Maksim Sisov <msisov@igalia.com>
Date: Fri, 24 Jan 2020 14:55:47 +0200
Subject: [PATCH] cef: port cefclient to gtk3.

---
 BUILD.gn                                           |  12 +-
 libcef/browser/osr/render_widget_host_view_osr.cc  |   1 -
 tests/cefclient/browser/browser_window_osr_gtk.cc  | 233 +++++++--------------
 tests/cefclient/browser/browser_window_osr_gtk.h   |   5 +-
 tests/cefclient/browser/dialog_handler_gtk.cc      |   4 +-
 .../browser/main_message_loop_multithreaded_gtk.cc |   2 +-
 tests/cefclient/browser/print_handler_gtk.cc       |   4 +-
 tests/cefclient/browser/root_window_gtk.cc         |  31 +++
 tests/cefclient/cefclient_gtk.cc                   |   7 +-
 tests/shared/browser/geometry_util.cc              |   5 +
 tests/shared/browser/geometry_util.h               |   1 +
 11 files changed, 125 insertions(+), 180 deletions(-)

diff --git a/BUILD.gn b/BUILD.gn
index 30d84d0..b46650c 100644
--- a/cef/BUILD.gn
+++ b/cef/BUILD.gn
@@ -2085,18 +2085,12 @@ if (is_mac) {
     pkg_config("gtk") {
       packages = [
         "gmodule-2.0",
-        "gtk+-2.0",
+        "gtk+-3.0",
         "gthread-2.0",
-        "gtk+-unix-print-2.0",
+        "gtk+-unix-print-3.0",
         "xi",
       ]
     }
-
-    pkg_config("gtkglext") {
-      packages = [
-        "gtkglext-1.0",
-      ]
-    }
   }
 
   if (is_linux) {
@@ -2178,12 +2172,12 @@ if (is_mac) {
 
       libs = [
         "X11",
+        "GL",
       ]
 
       if (cef_use_gtk) {
         configs += [
           ":gtk",
-          ":gtkglext",
         ]
       }
 
diff --git a/libcef/browser/osr/render_widget_host_view_osr.cc b/libcef/browser/osr/render_widget_host_view_osr.cc
index aa65ab8..05006f3 100644
--- a/cef/libcef/browser/osr/render_widget_host_view_osr.cc
+++ b/cef/libcef/browser/osr/render_widget_host_view_osr.cc
@@ -622,7 +622,6 @@ void CefRenderWidgetHostViewOSR::UpdateCursor(
   } else {
     platform_cursor = GetPlatformCursor(cursor_info.type);
   }
-
   handler->OnCursorChange(browser_impl_.get(), platform_cursor, cursor_type,
                           custom_cursor_info);
 #elif defined(OS_MACOSX)
diff --git a/tests/cefclient/browser/browser_window_osr_gtk.cc b/tests/cefclient/browser/browser_window_osr_gtk.cc
index 242b312..a2637b2 100644
--- a/cef/tests/cefclient/browser/browser_window_osr_gtk.cc
+++ b/cef/tests/cefclient/browser/browser_window_osr_gtk.cc
@@ -6,16 +6,14 @@
 
 #include <GL/gl.h>
 #include <gdk/gdk.h>
-#include <gdk/gdkkeysyms.h>
+#include <gdk/gdkkeysyms-compat.h>
 #include <gdk/gdkx.h>
 #include <glib-object.h>
 #include <gtk/gtk.h>
-#include <gtk/gtkgl.h>
 
 #define XK_3270  // for XK_3270_BackTab
 #include <X11/XF86keysym.h>
 #include <X11/Xcursor/Xcursor.h>
-#include <X11/extensions/XInput2.h>
 #include <X11/keysym.h>
 
 #include "include/base/cef_logging.h"
@@ -29,17 +27,10 @@ namespace client {
 
 namespace {
 
-// Major opcode of XInputExtension, or -1 if XInput 2.2 is not available.
-int g_xinput_extension = -1;
-
 // Static BrowserWindowOsrGtk::EventFilter needs to forward touch events
 // to correct browser, so we maintain a vector of all windows.
 std::vector<BrowserWindowOsrGtk*> g_browser_windows;
 
-bool IsTouchAvailable() {
-  return g_xinput_extension != -1;
-}
-
 int GetCefStateModifiers(guint state) {
   int modifiers = 0;
   if (state & GDK_SHIFT_MASK)
@@ -59,20 +50,6 @@ int GetCefStateModifiers(guint state) {
   return modifiers;
 }
 
-int GetCefStateModifiers(XIModifierState mods, XIButtonState buttons) {
-  guint state = mods.effective;
-  if (buttons.mask_len >= 1) {
-    if (XIMaskIsSet(buttons.mask, 1))
-      state |= GDK_BUTTON1_MASK;
-    if (XIMaskIsSet(buttons.mask, 2))
-      state |= GDK_BUTTON2_MASK;
-    if (XIMaskIsSet(buttons.mask, 3))
-      state |= GDK_BUTTON3_MASK;
-  }
-
-  return GetCefStateModifiers(state);
-}
-
 // From ui/events/keycodes/keyboard_codes_posix.h.
 enum KeyboardCode {
   VKEY_BACK = 0x08,
@@ -894,17 +871,20 @@ void GetWidgetRectInScreen(GtkWidget* widget, GdkRectangle* r) {
   // Get parent's left-top screen coordinates.
   gdk_window_get_root_origin(window, &x, &y);
   // Get parent's width and height.
-  gdk_drawable_get_size(window, &w, &h);
+  w = gdk_window_get_width(window);
+  h = gdk_window_get_height(window);
   // Get parent's extents including decorations.
   gdk_window_get_frame_extents(window, &extents);
 
   // X and Y calculations assume that left, right and bottom border sizes are
   // all the same.
   const gint border = (extents.width - w) / 2;
-  r->x = x + border + widget->allocation.x;
-  r->y = y + (extents.height - h) - border + widget->allocation.y;
-  r->width = widget->allocation.width;
-  r->height = widget->allocation.height;
+  GtkAllocation allocation;
+  gtk_widget_get_allocation(widget, &allocation);
+  r->x = x + border + allocation.x;
+  r->y = y + (extents.height - h) - border + allocation.y;
+  r->width = allocation.width;
+  r->height = allocation.height;
 }
 
 CefBrowserHost::DragOperationsMask GetDragOperationsMask(
@@ -924,31 +904,25 @@ CefBrowserHost::DragOperationsMask GetDragOperationsMask(
 
 class ScopedGLContext {
  public:
-  ScopedGLContext(GtkWidget* widget, bool swap_buffers)
-      : swap_buffers_(swap_buffers) {
-    GdkGLContext* glcontext = gtk_widget_get_gl_context(widget);
-    gldrawable_ = gtk_widget_get_gl_drawable(widget);
-    is_valid_ = gdk_gl_drawable_gl_begin(gldrawable_, glcontext);
+  ScopedGLContext(GtkWidget* widget, bool swap_buffers) : swap_buffers_(swap_buffers), widget_(widget) {
+    gtk_gl_area_make_current(GTK_GL_AREA(widget));
+    is_valid_ = gtk_gl_area_get_error(GTK_GL_AREA(widget)) == NULL;
+    if (swap_buffers_ && is_valid_) {
+      gtk_gl_area_queue_render(GTK_GL_AREA(widget_));
+      gtk_gl_area_attach_buffers(GTK_GL_AREA(widget));
+    }
   }
 
   virtual ~ScopedGLContext() {
-    if (is_valid_) {
-      gdk_gl_drawable_gl_end(gldrawable_);
-
-      if (swap_buffers_) {
-        if (gdk_gl_drawable_is_double_buffered(gldrawable_))
-          gdk_gl_drawable_swap_buffers(gldrawable_);
-        else
-          glFlush();
-      }
-    }
+    if (swap_buffers_ && is_valid_)
+      glFlush();
   }
 
   bool IsValid() const { return is_valid_; }
 
  private:
   bool swap_buffers_;
-  GdkGLDrawable* gldrawable_;
+  GtkWidget* const widget_;
   bool is_valid_;
   ScopedGdkThreadsEnter scoped_gdk_threads_;
 };
@@ -1012,12 +986,12 @@ void BrowserWindowOsrGtk::CreateBrowser(
 
   // Retrieve the X11 Window ID for the GTK parent window.
   GtkWidget* window =
-      gtk_widget_get_ancestor(GTK_WIDGET(parent_handle), GTK_TYPE_WINDOW);
-  ::Window xwindow = GDK_WINDOW_XID(gtk_widget_get_window(window));
-  DCHECK(xwindow);
+    gtk_widget_get_ancestor(GTK_WIDGET(parent_handle), GTK_TYPE_WINDOW);
+  CefWindowHandle handle = GDK_WINDOW_XID(gtk_widget_get_window(window));
+  DCHECK(handle);
 
   CefWindowInfo window_info;
-  window_info.SetAsWindowless(xwindow);
+  window_info.SetAsWindowless(handle);
 
   // Create the browser asynchronously.
   CefBrowserHost::CreateBrowser(window_info, client_handler_,
@@ -1173,11 +1147,13 @@ void BrowserWindowOsrGtk::GetViewRect(CefRefPtr<CefBrowser> browser,
 
   // The simulated screen and view rectangle are the same. This is necessary
   // for popup menus to be located and sized inside the view.
-  rect.width = DeviceToLogical(glarea_->allocation.width, device_scale_factor);
+  GtkAllocation allocation;
+  gtk_widget_get_allocation(glarea_, &allocation);
+  rect.width = DeviceToLogical(allocation.width, device_scale_factor);
   if (rect.width == 0)
     rect.width = 1;
   rect.height =
-      DeviceToLogical(glarea_->allocation.height, device_scale_factor);
+      DeviceToLogical(allocation.height, device_scale_factor);
   if (rect.height == 0)
     rect.height = 1;
 }
@@ -1374,18 +1350,14 @@ void BrowserWindowOsrGtk::Create(ClientWindowHandle parent_handle) {
 
   ScopedGdkThreadsEnter scoped_gdk_threads;
 
-  glarea_ = gtk_drawing_area_new();
+  glarea_ = gtk_gl_area_new();
   DCHECK(glarea_);
 
-  GdkGLConfig* glconfig =
-      gdk_gl_config_new_by_mode(static_cast<GdkGLConfigMode>(
-          GDK_GL_MODE_RGB | GDK_GL_MODE_DEPTH | GDK_GL_MODE_DOUBLE));
-  DCHECK(glconfig);
-
-  gtk_widget_set_gl_capability(glarea_, glconfig, NULL, TRUE, GDK_GL_RGBA_TYPE);
-
   gtk_widget_set_can_focus(glarea_, TRUE);
 
+  gtk_gl_area_set_auto_render (GTK_GL_AREA(glarea_),
+                             FALSE);
+
   g_signal_connect(G_OBJECT(glarea_), "size_allocate",
                    G_CALLBACK(&BrowserWindowOsrGtk::SizeAllocation), this);
 
@@ -1415,6 +1387,8 @@ void BrowserWindowOsrGtk::Create(ClientWindowHandle parent_handle) {
                    G_CALLBACK(&BrowserWindowOsrGtk::FocusEvent), this);
   g_signal_connect(G_OBJECT(glarea_), "focus_out_event",
                    G_CALLBACK(&BrowserWindowOsrGtk::FocusEvent), this);
+  g_signal_connect(G_OBJECT(glarea_), "touch-event",
+                   G_CALLBACK(&BrowserWindowOsrGtk::TouchEvent), this);
 
   RegisterDragDrop();
 
@@ -1422,11 +1396,6 @@ void BrowserWindowOsrGtk::Create(ClientWindowHandle parent_handle) {
 
   // Make the GlArea visible in the parent container.
   gtk_widget_show_all(parent_handle);
-
-  InitializeXinput(xdisplay_);
-
-  if (IsTouchAvailable())
-    RegisterTouch();
 }
 
 // static
@@ -1514,7 +1483,7 @@ gint BrowserWindowOsrGtk::ClickEvent(GtkWidget* widget,
 // static
 gint BrowserWindowOsrGtk::KeyEvent(GtkWidget* widget,
                                    GdkEventKey* event,
-                                   BrowserWindowOsrGtk* self) {
+                                   BrowserWindowOsrGtk* self) {         
   CEF_REQUIRE_UI_THREAD();
 
   if (!self->browser_.get())
@@ -1570,7 +1539,7 @@ gint BrowserWindowOsrGtk::KeyEvent(GtkWidget* widget,
 // static
 gint BrowserWindowOsrGtk::MoveEvent(GtkWidget* widget,
                                     GdkEventMotion* event,
-                                    BrowserWindowOsrGtk* self) {
+                                    BrowserWindowOsrGtk* self) {                
   CEF_REQUIRE_UI_THREAD();
 
   if (!self->browser_.get())
@@ -1627,7 +1596,7 @@ gint BrowserWindowOsrGtk::MoveEvent(GtkWidget* widget,
 // static
 gint BrowserWindowOsrGtk::ScrollEvent(GtkWidget* widget,
                                       GdkEventScroll* event,
-                                      BrowserWindowOsrGtk* self) {
+                                      BrowserWindowOsrGtk* self) {   
   CEF_REQUIRE_UI_THREAD();
 
   if (!self->browser_.get())
@@ -1664,6 +1633,9 @@ gint BrowserWindowOsrGtk::ScrollEvent(GtkWidget* widget,
     case GDK_SCROLL_RIGHT:
       deltaX = -scrollbarPixelsPerGtkTick;
       break;
+    case GDK_SCROLL_SMOOTH:
+      NOTIMPLEMENTED();
+      break;
   }
 
   host->SendMouseWheelEvent(mouse_event, deltaX, deltaY);
@@ -1680,106 +1652,49 @@ gint BrowserWindowOsrGtk::FocusEvent(GtkWidget* widget,
   return TRUE;
 }
 
-void BrowserWindowOsrGtk::TouchEvent(CefXIDeviceEvent event) {
-  if (!browser_.get())
-    return;
+// static
+gboolean BrowserWindowOsrGtk::TouchEvent(GtkWidget* widget,
+                                         GdkEventTouch* event,
+                                         BrowserWindowOsrGtk* self) {
+  CEF_REQUIRE_UI_THREAD();
+
+  if (!self->browser_.get())
+    return TRUE;
 
-  XIDeviceEvent* ev = static_cast<XIDeviceEvent*>(event);
-  CefTouchEvent cef_event;
-  switch (ev->evtype) {
-    case XI_TouchBegin:
-      cef_event.type = CEF_TET_PRESSED;
+  CefRefPtr<CefBrowserHost> host = self->browser_->GetHost();
+
+  float device_scale_factor;
+  {
+    base::AutoLock lock_scope(self->lock_);
+    device_scale_factor = self->device_scale_factor_;
+  }
+
+  CefTouchEvent touch_event;
+  switch (event->type) {
+    case GDK_TOUCH_BEGIN:
+      touch_event.type = CEF_TET_PRESSED;
       break;
-    case XI_TouchUpdate:
-      cef_event.type = CEF_TET_MOVED;
+    case GDK_TOUCH_UPDATE:
+      touch_event.type = CEF_TET_MOVED;
       break;
-    case XI_TouchEnd:
-      cef_event.type = CEF_TET_RELEASED;
+    case GDK_TOUCH_END:
+      touch_event.type = CEF_TET_RELEASED;
       break;
     default:
-      return;
-  }
-
-  cef_event.id = ev->detail;
-  cef_event.x = ev->event_x;
-  cef_event.y = ev->event_y;
-  cef_event.radius_x = 0;
-  cef_event.radius_y = 0;
-  cef_event.rotation_angle = 0;
-  cef_event.pressure = 0;
-  cef_event.modifiers = GetCefStateModifiers(ev->mods, ev->buttons);
-
-  browser_->GetHost()->SendTouchEvent(cef_event);
-}
-
-void BrowserWindowOsrGtk::RegisterTouch() {
-  GdkWindow* glwindow = gtk_widget_get_window(glarea_);
-  ::Window xwindow = GDK_WINDOW_XID(glwindow);
-  uint32_t bitMask = XI_TouchBeginMask | XI_TouchUpdateMask | XI_TouchEndMask;
-
-  XIEventMask mask;
-  mask.deviceid = XIAllMasterDevices;
-  mask.mask = reinterpret_cast<unsigned char*>(&bitMask);
-  mask.mask_len = sizeof(bitMask);
-  XISelectEvents(xdisplay_, xwindow, &mask, 1);
-}
-
-// static
-GdkFilterReturn BrowserWindowOsrGtk::EventFilter(GdkXEvent* gdk_xevent,
-                                                 GdkEvent* event,
-                                                 gpointer data) {
-  XEvent* xevent = static_cast<XEvent*>(gdk_xevent);
-  if (xevent->type == GenericEvent &&
-      xevent->xgeneric.extension == g_xinput_extension) {
-    XGetEventData(xevent->xcookie.display, &xevent->xcookie);
-    XIDeviceEvent* ev = static_cast<XIDeviceEvent*>(xevent->xcookie.data);
-
-    if (!ev)
-      return GDK_FILTER_REMOVE;
-
-    for (BrowserWindowOsrGtk* browser_window : g_browser_windows) {
-      GtkWidget* widget = browser_window->GetWindowHandle();
-      ::Window xwindow = GDK_WINDOW_XID(gtk_widget_get_window(widget));
-      if (xwindow == ev->event) {
-        browser_window->TouchEvent(ev);
-        break;
-      }
-    }
-
-    XFreeEventData(xevent->xcookie.display, &xevent->xcookie);
-    // Even if we didn't find a consumer for this event, we will make sure Gdk
-    // doesn't attempt to process the event, since it can't parse GenericEvents
-    return GDK_FILTER_REMOVE;
+      return TRUE;
   }
 
-  return GDK_FILTER_CONTINUE;
-}
+  touch_event.x = event->x;
+  touch_event.y = event->y;
+  touch_event.radius_x = 0;
+  touch_event.radius_y = 0;
+  touch_event.rotation_angle = 0;
+  touch_event.pressure = 0;
+  DeviceToLogical(touch_event, device_scale_factor);
+  touch_event.modifiers = GetCefStateModifiers(event->state);
 
-// static
-void BrowserWindowOsrGtk::InitializeXinput(XDisplay* xdisplay) {
-  static bool initialized = false;
-  if (initialized)
-    return;
-  initialized = true;
-
-  int firstEvent, firstError;
-  if (XQueryExtension(xdisplay, "XInputExtension", &g_xinput_extension,
-                      &firstEvent, &firstError)) {
-    int major = 2, minor = 2;
-    // X Input Extension 2.2 is needed for multitouch events.
-    if (XIQueryVersion(xdisplay, &major, &minor) == Success) {
-      // Ideally we would add an event filter for each glarea_ window
-      // separately, but unfortunately GDK can't parse X GenericEvents
-      // which have the target window stored in different way compared
-      // to other X events. That is why we add this global event filter
-      // just once, and dispatch the event to correct BrowserWindowOsrGtk
-      // manually.
-      gdk_window_add_filter(nullptr, &BrowserWindowOsrGtk::EventFilter,
-                            nullptr);
-    } else {
-      g_xinput_extension = -1;
-    }
-  }
+  host->SendTouchEvent(touch_event);
+  return TRUE;
 }
 
 bool BrowserWindowOsrGtk::IsOverPopupWidget(int x, int y) const {
diff --git a/tests/cefclient/browser/browser_window_osr_gtk.h b/tests/cefclient/browser/browser_window_osr_gtk.h
index 33083e0..65c98bc 100644
--- a/cef/tests/cefclient/browser/browser_window_osr_gtk.h
+++ b/cef/tests/cefclient/browser/browser_window_osr_gtk.h
@@ -117,8 +117,10 @@ class BrowserWindowOsrGtk : public BrowserWindow,
   static gint FocusEvent(GtkWidget* widget,
                          GdkEventFocus* event,
                          BrowserWindowOsrGtk* self);
+  static gboolean TouchEvent(GtkWidget* widget,
+                             GdkEventTouch* event,
+                             BrowserWindowOsrGtk* self);
 
-  void TouchEvent(CefXIDeviceEvent event);
   void RegisterTouch();
 
   bool IsOverPopupWidget(int x, int y) const;
@@ -176,7 +178,6 @@ class BrowserWindowOsrGtk : public BrowserWindow,
   static GdkFilterReturn EventFilter(GdkXEvent* gdk_xevent,
                                      GdkEvent* event,
                                      gpointer data);
-  static void InitializeXinput(XDisplay* xdisplay);
 
   XDisplay* xdisplay_;
 
diff --git a/tests/cefclient/browser/dialog_handler_gtk.cc b/tests/cefclient/browser/dialog_handler_gtk.cc
index 1958a52..677c1fc 100644
--- a/cef/tests/cefclient/browser/dialog_handler_gtk.cc
+++ b/cef/tests/cefclient/browser/dialog_handler_gtk.cc
@@ -135,10 +135,10 @@ GtkWindow* GetWindow(CefRefPtr<CefBrowser> browser) {
   scoped_refptr<RootWindow> root_window =
       RootWindow::GetForBrowser(browser->GetIdentifier());
   if (root_window) {
-    GtkWindow* window = GTK_WINDOW(root_window->GetWindowHandle());
+    GtkWidget* window = root_window->GetWindowHandle();
     if (!window)
       LOG(ERROR) << "No GtkWindow for browser";
-    return window;
+    return GTK_WINDOW(window);
   }
   return nullptr;
 }
diff --git a/tests/cefclient/browser/main_message_loop_multithreaded_gtk.cc b/tests/cefclient/browser/main_message_loop_multithreaded_gtk.cc
index d4a0443..33ad0e7 100644
--- a/cef/tests/cefclient/browser/main_message_loop_multithreaded_gtk.cc
+++ b/cef/tests/cefclient/browser/main_message_loop_multithreaded_gtk.cc
@@ -5,7 +5,7 @@
 #include "tests/cefclient/browser/main_message_loop_multithreaded_gtk.h"
 
 #include <X11/Xlib.h>
-#include <gtk/gtkmain.h>
+#include <gtk/gtk.h>
 
 #include "include/base/cef_bind.h"
 #include "include/base/cef_logging.h"
diff --git a/tests/cefclient/browser/print_handler_gtk.cc b/tests/cefclient/browser/print_handler_gtk.cc
index 922c85b..2dc7b47 100644
--- a/cef/tests/cefclient/browser/print_handler_gtk.cc
+++ b/cef/tests/cefclient/browser/print_handler_gtk.cc
@@ -539,7 +539,7 @@ struct ClientPrintHandlerGtk::PrintHandler {
     }
   }
 
-  void OnJobCompleted(GtkPrintJob* print_job, GError* error) {
+  void OnJobCompleted(GtkPrintJob* print_job, const GError* error) {
     // Continue() will result in a call to ClientPrintHandlerGtk::OnPrintReset
     // which deletes |this|. Execute it asnychronously so the call stack has a
     // chance to unwind.
@@ -556,7 +556,7 @@ struct ClientPrintHandlerGtk::PrintHandler {
 
   static void OnJobCompletedThunk(GtkPrintJob* print_job,
                                   void* handler,
-                                  GError* error) {
+                                  const GError* error) {
     static_cast<PrintHandler*>(handler)->OnJobCompleted(print_job, error);
   }
 
diff --git a/tests/cefclient/browser/root_window_gtk.cc b/tests/cefclient/browser/root_window_gtk.cc
index ba48589..2f65cee 100644
--- a/cef/tests/cefclient/browser/root_window_gtk.cc
+++ b/cef/tests/cefclient/browser/root_window_gtk.cc
@@ -29,6 +29,36 @@ namespace {
 
 const char kMenuIdKey[] = "menu_id";
 
+void UseDefaultX11VisualForGtk(GtkWidget* widget) {
+#if GTK_CHECK_VERSION(3,15,1)
+  // GTK+ > 3.15.1 uses an X11 visual optimized for GTK+'s OpenGL stuff
+  // since revid dae447728d: https://github.com/GNOME/gtk/commit/dae447728d
+  // However, it breaks CEF: https://github.com/cztomczak/cefcapi/issues/9
+  // Let's use the default X11 visual instead of the GTK's blessed one.
+  // Copied from: https://github.com/cztomczak/cefcapi.
+  GdkScreen* screen = gdk_screen_get_default();
+  GList* visuals = gdk_screen_list_visuals(screen);
+
+  GdkX11Screen* x11_screen = GDK_X11_SCREEN(screen);
+  if (x11_screen == NULL)
+    return;
+
+  Visual* default_xvisual =
+      DefaultVisual(GDK_SCREEN_XDISPLAY(x11_screen),
+                    GDK_SCREEN_XNUMBER(x11_screen));
+  GList* cursor = visuals;
+  while (cursor != NULL) {
+    GdkVisual* visual = GDK_X11_VISUAL(cursor->data);
+    if (default_xvisual->visualid == gdk_x11_visual_get_xvisual(visual)->visualid) {
+        gtk_widget_set_visual(widget, visual);
+        break;
+    }
+    cursor = cursor->next;
+  }
+  g_list_free(visuals);
+#endif
+}
+
 bool IsWindowMaximized(GtkWindow* window) {
   GdkWindow* gdk_window = gtk_widget_get_window(GTK_WIDGET(window));
   gint state = gdk_window_get_state(gdk_window);
@@ -147,6 +177,7 @@ void RootWindowGtk::Show(ShowMode mode) {
   ScopedGdkThreadsEnter scoped_gdk_threads;
 
   // Show the GTK window.
+  UseDefaultX11VisualForGtk(GTK_WIDGET(window_));
   gtk_widget_show_all(window_);
 
   if (mode == ShowMinimized)
diff --git a/tests/cefclient/cefclient_gtk.cc b/tests/cefclient/cefclient_gtk.cc
index 02ae571..b79f24e 100644
--- a/cef/tests/cefclient/cefclient_gtk.cc
+++ b/cef/tests/cefclient/cefclient_gtk.cc
@@ -3,7 +3,6 @@
 // can be found in the LICENSE file.
 
 #include <gtk/gtk.h>
-#include <gtk/gtkgl.h>
 
 #include <X11/Xlib.h>
 #undef Success     // Definition conflicts with cef_message_router.h
@@ -110,13 +109,13 @@ int RunMain(int argc, char* argv[]) {
   // Initialize CEF.
   context->Initialize(main_args, settings, app, nullptr);
 
+  // Force Gtk to use Xwayland (in case a Wayland compositor is being used).
+  gdk_set_allowed_backends("x11");
+
   // The Chromium sandbox requires that there only be a single thread during
   // initialization. Therefore initialize GTK after CEF.
   gtk_init(&argc, &argv_copy);
 
-  // Perform gtkglext initialization required by the OSR example.
-  gtk_gl_init(&argc, &argv_copy);
-
   // Install xlib error handlers so that the application won't be terminated
   // on non-fatal errors. Must be done after initializing GTK.
   XSetErrorHandler(XErrorHandlerImpl);
diff --git a/tests/shared/browser/geometry_util.cc b/tests/shared/browser/geometry_util.cc
index 206edbc..f7c3210 100644
--- a/cef/tests/shared/browser/geometry_util.cc
+++ b/cef/tests/shared/browser/geometry_util.cc
@@ -30,4 +30,9 @@ void DeviceToLogical(CefMouseEvent& value, float device_scale_factor) {
   value.y = DeviceToLogical(value.y, device_scale_factor);
 }
 
+void DeviceToLogical(CefTouchEvent& value, float device_scale_factor) {
+  value.x = DeviceToLogical(value.x, device_scale_factor);
+  value.y = DeviceToLogical(value.y, device_scale_factor);
+}
+
 }  // namespace client
diff --git a/tests/shared/browser/geometry_util.h b/tests/shared/browser/geometry_util.h
index 1f1e188..fc2c476 100644
--- a/cef/tests/shared/browser/geometry_util.h
+++ b/cef/tests/shared/browser/geometry_util.h
@@ -17,6 +17,7 @@ CefRect LogicalToDevice(const CefRect& value, float device_scale_factor);
 // Convert |value| from device coordinates to logical coordinates.
 int DeviceToLogical(int value, float device_scale_factor);
 void DeviceToLogical(CefMouseEvent& value, float device_scale_factor);
+void DeviceToLogical(CefTouchEvent& value, float device_scale_factor);
 
 }  // namespace client
 
-- 
2.10.5

