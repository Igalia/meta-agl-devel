Disable code that requires clang.

Chromium assumes clang and doesn't support GCC officially, so the code may be
incompatible.

Upstream-Status: ???
Signed-off-by: Alexander Dunaev <agunaev@igalia.com>

--- a/build/config/compiler/BUILD.gn
+++ b/build/config/compiler/BUILD.gn
@@ -1408,6 +1408,14 @@ config("default_warnings") {
       cflags_cc += [
         # See comment for -Wno-c++11-narrowing.
         "-Wno-narrowing",
+        # Suppress GCC's mumbling about clang's spells.
+        "-Wno-attributes",
+        "-Wno-pragmas",
+        "-Wno-return-type",
+        "-Wno-unknown-pragmas",
+        "-Wno-unused-but-set-variable",
+        "-Wno-unused-function",
+        "-Wno-unused-variable",
       ]

       # -Wno-class-memaccess warns about hash table and vector in blink.
--- a/chrome/browser/apps/platform_apps/audio_focus_web_contents_observer.h
+++ b/chrome/browser/apps/platform_apps/audio_focus_web_contents_observer.h
@@ -22,7 +22,6 @@ class AudioFocusWebContentsObserver

  private:
   friend class content::WebContentsUserData<AudioFocusWebContentsObserver>;
-  friend class AudioFocusWebContentsObserver;
   friend class AudioFocusWebContentsObserverBrowserTest;

   explicit AudioFocusWebContentsObserver(content::WebContents*);
--- a/media/base/media_log_properties_helper.h
+++ b/media/base/media_log_properties_helper.h
@@ -83,7 +83,7 @@ struct MediaLogPropertyTypeConverter<std::vector<T>> {

 // Specializer for sending AudioDecoderConfigs to the media tab in devtools.
 template <>
-struct internal::MediaLogPropertyTypeConverter<media::AudioDecoderConfig> {
+struct MediaLogPropertyTypeConverter<media::AudioDecoderConfig> {
   static base::Value Convert(const AudioDecoderConfig& value) {
     base::Value result(base::Value::Type::DICTIONARY);
     result.SetStringKey("codec", GetCodecName(value.codec()));
@@ -114,7 +114,7 @@ struct internal::MediaLogPropertyTypeConverter<media::AudioDecoderConfig> {

 // Specializer for sending VideoDecoderConfigs to the media tab in devtools.
 template <>
-struct internal::MediaLogPropertyTypeConverter<VideoDecoderConfig> {
+struct MediaLogPropertyTypeConverter<VideoDecoderConfig> {
   static base::Value Convert(const VideoDecoderConfig& value) {
     base::Value result(base::Value::Type::DICTIONARY);
     result.SetStringKey("codec", GetCodecName(value.codec()));
--- a/net/third_party/quiche/src/quic/core/frames/quic_frame.h
+++ b/net/third_party/quiche/src/quic/core/frames/quic_frame.h
@@ -113,8 +113,8 @@ struct QUIC_EXPORT_PRIVATE QuicFrame {

 static_assert(sizeof(QuicFrame) <= 24,
               "Frames larger than 24 bytes should be referenced by pointer.");
-static_assert(offsetof(QuicStreamFrame, type) == offsetof(QuicFrame, type),
-              "Offset of |type| must match in QuicFrame and QuicStreamFrame");
+// static_assert(offsetof(QuicStreamFrame, type) == offsetof(QuicFrame, type),
+//            "Offset of |type| must match in QuicFrame and QuicStreamFrame");

 // A inline size of 1 is chosen to optimize the typical use case of
 // 1-stream-frame in QuicTransmissionInfo.retransmittable_frames.

--- a/net/third_party/quiche/src/quic/core/frames/quic_inlined_frame.h
+++ b/net/third_party/quiche/src/quic/core/frames/quic_inlined_frame.h
@@ -17,8 +17,8 @@ namespace quic {
 template <typename DerivedT>
 struct QUIC_EXPORT_PRIVATE QuicInlinedFrame {
   QuicInlinedFrame(QuicFrameType type) : type(type) {
-    static_assert(offsetof(DerivedT, type) == 0,
-                  "type must be the first field.");
+//    static_assert(offsetof(DerivedT, type) == 0,
+//                  "type must be the first field.");
     static_assert(sizeof(DerivedT) <= 24,
                   "Frames larger than 24 bytes should not be inlined.");
   }
--- a/ui/aura/window.h
+++ b/ui/aura/window.h
@@ -41,7 +41,7 @@
 #include "ui/gfx/native_widget_types.h"

 #if defined(OS_MACOSX)
-#error This file must not be included on macOS; Chromium Mac doesn't use Aura.
+#error "This file must not be included on macOS; Chromium Mac doesn't use Aura."
 #endif

 namespace cc {
--- a/ui/base/clipboard/clipboard_format_type.h
+++ b/ui/base/clipboard/clipboard_format_type.h
@@ -96,7 +96,6 @@ struct COMPONENT_EXPORT(BASE_CLIPBOARD_TYPES) ClipboardFormatType {

  private:
   friend class base::NoDestructor<ClipboardFormatType>;
-  friend struct ClipboardFormatType;

   // Platform-specific glue used internally by the ClipboardFormatType struct.
   // Each platform should define at least one of each of the following:
--- a/ui/ozone/platform/wayland/host/wayland_window.cc
+++ b/ui/ozone/platform/wayland/host/wayland_window.cc
@@ -29,8 +29,6 @@

 namespace ui {

-namespace {
-
 // Factory, which decides which version type of xdg object to build.
 class XDGShellObjectFactory {
  public:
@@ -83,8 +81,6 @@ gfx::Rect TranslateBoundsToTopLevelCoordinates(const gfx::Rect& child_bounds,
                    child_bounds.size());
 }

-}  // namespace
-
 WaylandWindow::WaylandWindow(PlatformWindowDelegate* delegate,
                              WaylandConnection* connection)
     : delegate_(delegate),
--- a/ui/ozone/platform/wayland/host/wayland_window.h
+++ b/ui/ozone/platform/wayland/host/wayland_window.h
@@ -34,10 +34,7 @@ class OSExchangeData;
 class WaylandConnection;
 class ShellPopupWrapper;
 class ShellSurfaceWrapper;
-
-namespace {
 class XDGShellObjectFactory;
-}  // namespace

 class WaylandWindow : public PlatformWindow,
                       public PlatformEventDispatcher,
--- a/ui/ozone/platform/wayland/host/xdg_surface_wrapper_impl.h
+++ b/ui/ozone/platform/wayland/host/xdg_surface_wrapper_impl.h
@@ -72,7 +72,7 @@ class XDGSurfaceWrapperImpl : public ShellSurfaceWrapper {
   static void CloseTopLevelV6(void* data,
                               struct zxdg_toplevel_v6* zxdg_toplevel_v6);

-  xdg_surface* xdg_surface() const;
+  struct xdg_surface* xdg_surface() const;
   zxdg_surface_v6* zxdg_surface() const;

  private:
